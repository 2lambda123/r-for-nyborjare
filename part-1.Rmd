---
title: Grundkurs i R
author: Love Hansson och Thomas Reinholdsson
job: Pensionsmyndigheten
widgets: [quiz]
framework: io2012
mode: selfcontained
hitheme: tomorrow
---


## Lärandemål

- Förstå skillnaden på patchwork-språk som SAS och äkta programmeringsspråk som R
- Sammanställa deskriptiv statistik om data med enklare funktioner
- Använda ggplot och grafiska funktioner för deskription och exploration av data
- Använda och förstå ett flertal datastrukturer
- Installera och använda paket
- Hämta data från olika källor (Excel, MiDAS, Coldbir, Pedal)
- Lagra data i olika format
- Självständigt inhämta ny kunskap och hitta svar på frågor om R (vara en del av R:s community)

---


## Kurslitteratur

- [Advanced R programming](http://adv-r.had.co.nz) av Hadley Wickham

---

## Datastrukturer

Det finns flera olika datatyper som används inom R, de vanligaste listas nedan:

- Vektorer
- Listor
- Faktorer
- Matriser
- "Data frames"

---

### Vektorer

De vanligaste typerna av vektorer är:

```{r}
logical <- c(T, FALSE, TRUE, FALSE)
numeric <- c(1, 2.5, 4.5)
integer <- c(1L, 6L, 10L)
character <- c("these are", "some strings")
```

Man kan lägga samman vektorer och de "plattas" då ut:

```{r}
c(1, 2, 3, 4)
c(1, c(2, c(3, 4)))
```

---

### Vektorer forts ...

För att testa eller se vilken datatyp en variabel är:

```{r}
typeof(integer)
is.integer(integer)
is.double(integer)
```

Man kan även kontrollera för om det är en vektor:

```{r}
is.vector(integer)
```

---

### Vektorer forts ...

Vektorer kan enbart innehålla en datatyp. När man kombinerar flera olika datatyper, så får man tänka på att de konverteras till en och samma typ.

```{r}
c("a", 1)
c("a", T)
c(1, T, F)
```

När logiska vektorer (`TRUE`/`FALSE`) konverteras så ersätts de med `1` och `0`. Därav kan man t.ex. använda sig av `sum()`.

---

### Listor

Listor kan innehålla olika typer av vektorer:

```{r}
x <- list(1:3, "a", c(T, F, T), c(2.3, 5.9))
```

Dessutom så kan de innehålla ytterligare listor, vilket medför att de ibland kallas ibland för __recursive vectors__.

```{r}
x <- list(list(1,2), list("a","b","c"), 5:9)
str(x)
```

---

### Attribut och namn

Alla objekt kan ha attribut kopplade till sig. T.ex. använder man ofta namn för listor och vektorer.

__Vektorer__

```{r}
x <- c(a = 1, b = 2, c = 3)
x <- c("a" = 1, "b" = 2, "c" = 3)
x
```

Man kan även ändra eller lägga till namn i efterhand:

```{r}
names(x) <- c("x", "y", "z")
```

__Listor__

```{r}
x <- list(a = 1, b = 2, list(c = 3, d = 4))
```

---

### Faktorer

Faktorer inkluderar en slags uppslagstabell för kodvärden:

```{r}
x <- factor(c("a", "b", "b", "a"))
x
levels(x)
```

Observera att man **inte** kan kombinera två faktorvariabler:

```{r}
c(factor("a"), factor("b"))
```

Därför bör man vara extra varsam när man använder sig av faktorvariabler.

---

### Matriser

```{r}
matrix(1:6, ncol = 3)
array(1:12, c(2, 3, 2))
```

---

### Data frames

`data.frame` är det vanligaste sättet att lagra data i R. Det flexibla tabellformatet gör det enkelt att bearbeta data och använda för dataanalys.

```{r}
data.frame(x = 1:3, y = c("a", "b", "c"))
```

Eftersom det kan vara problematiskt att jobba med faktorer, så kan man ange med argumentet `stringsAsFactors = FALSE` att text ska vara `character`:

```{r}
df <- data.frame(
  x = 1:3, 
  y = c("a", "b", "c"), 
  stringsAsFactors = FALSE
)
```

---

## Subsetting

När vi har data vill vi kunna arbeta med delar av data. Detta kallas __subsetting__.

Valet av metod för att hämta ut delar av data beror på vilken __datatyp__ vi använder oss av.

R erbjuder __flera metoder__ för att hämta ut data för varje datatyp.

---

### Grundläggande operationer

Data i R lagras i en __datastruktur__. Om vi anropar hela strukturen får vi, vanligtvis, ut _all_ data i strukturen.

För att hämta delar av data ur en struktur använder vi metoder kallade __operatorer__ på strukturen.

Det finns tre sådana operatorer:
- __[__: Hämta ett subset av data som matchar en uppsättning kriterier
- __[[__: Hämta ett enda namngivet värde ur en datastruktur
- __$__: Hämta en namngiven variabel/kolumn ur en sammansatt datastruktur

Operatorerna anges direkt efter ett anrop av en datastruktur, på formen __mindata$id__ eller __minlista[2]__.

---

### Enkla vektorer

Data:
```{r,results="hide"}
x <- c(aa=2.1, bb=4.2, cc=3.3, dd=5.4)
```

Metoder för dataextrahering:
```{r,results="hide"}
x[c(1,2)] # Välj ett eller flera element
x[order(x)] # Välj alla element, sorterade
x[['aa']] # Välj ett, namngivet eller numrerat, element
```

---

### Listor

De metoder som fungerar för listor fungerar _oftast_ även för vektorer.

Data:
```{r,results="hide"}
ll <- list(2.1, 4.2, 3.3, 5.4)
```

Metoder för dataextrahering:
```{r,results="hide"}
ll[c(1,2)]
ll[[1]]

```

---

### data.frame()

data.frame är R:s grundläggande datastruktur för data på tabellform.

Data:
```{r,results="hide"}
DF <- data.frame(id=c(1:3),
value=c("Love", "Thomas", "Ole"))
```


Urval kan göras kolumnvis, radvis, eller enligt vissa kriterier. Observera kommatecknet i []-anropet!
```{r,results="hide"}
DF[c(1,2),] # Väljer raderna 1 och 2
DF[,c("value")] # Väljer kolumnen "value"
DF[DF$value=="Ole",] # Välj den rad där "value" == "Ole"
```

---

### data.table()

data.table fungerar ungefär som data.frame, men skiljer sig i vissa detaljer.

```{r,results="hide"}
DT <- data.table(id=c(4:6),
value=c("Cédric", "Elin", "Ingemar"))
```

Radvis urval fungerar som i data.frames, men kolumnvis urval skiljer sig markant. data.table ger även möjligheten att genomföra SQL-liknande beräkningar utan att behöva använda yttre funktioner.

```{r,results="hide"}
DT[c(1:2)] # Väljer raderna 1 och 2
DT[,list(value)] # Väljer kolumnen "value"
DT[,id2 := (5-id),by=id] # Skapar en ny variabel med värdena {1,0,-1}
```
<small>Observera att kommatecknet kan utelämnas i första exemplet!</small>

---

## Sortering och sampling

Två vanliga operationer på data är __sortering__ och __sampling__.

Sortering görs, något kontraintuitivt, _inte_ med kommandot __sort()__ utan med kommandot __order()__:
```{r,results="hide"}
DT[order(DT$id)] # Genomför en "proc sort" på tabellen DF
# DT[sort(DT$id2)] # Genererar ett fel
```

Sampling kan göras med kommandot __sample()__:
```{r,results="hide"}
# Sampla en vektor
vektor <- c(1:1000)
vektor_sample <- sample(vektor, 100)

# Sampla rader ur en data.frame
DT <- data.table(id=c(1:1000),namn=rep(c("Ny","Gammal"))) # Skapa tabell
antalrader <- nrow(DT) # Antal rader i tabellen
DT <- DT[sample(antalrader,10)] # Sampla tio rader ur DT

```
<small>OBS! Ibland genererar R inget fel vid användning av __sort()__, men producerar felaktiga resultat. __sort()__ bör användas med stor försiktighet.</small>

---

## En grundläggande "vokabulär"

Grundläggande funktioner i R

---

### Grunderna

```r
# De första funktionerna att lära sig
?
str

# Operatorer
%in%, match
=, <-
head, tail

# Logik
&, |, !, xor
all, any

# Flödeskontroll
if, &, |
for, while

```

---

### Matematik

```r
# Jämförelser
!=, ==, >, >=, <, <=
is.na

# Grundläggande matematik
max, min, prod, sum
mean, median, cor, sd, var
```

---


### Datatyper

```r
# Vektorer och matriser
c, matrix
length, dim, ncol, nrow
cbind, rbind
names, colnames, rownames

# Konverteringar
as.data.frame, as.list, as.character, as.numeric

# Städning och minneshantering
rm
gc
memory.size
tables

```

---



### I/O

```r
# Output
print, cat

# Läsa och skriva data
data
read.csv, write.csv,
fread
load, save
library(foreign)
```

---

## Funktioner

En viktig del av att utveckla i R är att arbeta med, och skapa, __funktioner__.

Funktioner används för att __återanvända kod__, hantera __tillfällig minnesanvändning__ och att skapa en __strukturerad programsyntax__.

Funktioner kan, med lite god vilja, liknas vid ett SAS-makro. Åtminstone om man bortser från att SAS-makron inte följer samma syntax som vanlig SAS-kod.

---

### Att skriva funktioner

En funktion består av en __argumentlista__ och en __kodmassa__ (och lite annat).

- Argumentlista: `function(x,y)`
- Kodmassa: `{ return(x^2+y) }`

---

### Exempel på funktioner

```{r}
sq <- function(x) {
   x^2
}

sq(5)

```

```{r}
binom_coeff <- function(x,y) {
   numerator <- factorial(x)
   denominator <- factorial(y) * factorial(x-y)
   
   return(numerator/denominator)
}

binom_coeff(5,2)

```

---

## Pakethantering

R:s basfunktionalitet utvidgas med hjälp av funktioner.

Dessa är lagrade i __paket__ som kan läsas in i på begäran.

De flesta paket är lagrade på R-projektets paketserver __CRAN__.


---

### Ladda ett paket i R

Ett paket laddas med någon av funtionerna `require()` eller `library()`:

```{r,results="hide"}
require(stats)
library(class)
```

De funktioner som ingår i paketet kan nu användas i R:

```{r}
x <- rnorm(1000,0,1) # Skapa 1000 värden ~ N(0,1)
y <- rep(1:10,100) # Skapa indexvariabel

lm(y ~ x) # Använd funktion ur stats-paketet för linjär regression
```

---

### Installera nya paket

Paket i R kan installeras via internet, eller via en nedladdad zip-fil. Allra enklast är att ladda ned paketen via R:s inbyggda pakethanterare:


```{r, eval=F}
install.packages("ggplot2") # Installera paketet ggplot2 från CRAN
```

Vissa paket är lagrade på open source-plattformen GitHub, och måste installeras därifrån:

```{r,results="hide"}
require(devtools)

# Installera Coldbir-paketet från GitHub
install_github("Coldbir","SwedishPensionsAgency")
```

---



---


## Grafik och dataanalys

- ggplot2

---

## Externa datakällor

- pedal
- XLConnect

---

### Coldbir

Coldbir är en kolumndatabas i R - en vidareutveckling av tidigare midAUX (MIDAS).

Paketet har som mål att med lite kod och simpel syntax erbjuda snabb läs-/skrivhastighet, för att göra det enklare och snabbare att analysera data i R.

Dessutom finns stöd för hantering av dokumentation (t.ex. beskrivning av variabler).

Installera och ladda paket:

```{r, eval=F}
devtools::install_github('Coldbir', 'SthlmR')
library(Coldbir)
```

Skapa ny databaskoppling och ange sökväg:

```{r, eval=F}
a <- cdb('Q:/myDatabase')
```

Än sålänge har inget skapats - det är först när data läggs till som detta sker, därav lägger vi till ett dataset:

```{r, eval=F}
a[] <- ggplot2::diamonds
```

Hämta dataset:

```{r, eval=F}
dt <- a[]
```

Hämta variabel:

```{r, eval=F}
var <- a["cut"]
```

Skapa ny variabel:

```{r, eval=F}
a["x_plus_y"] <- a["x"] + a["y"]
```

Tänk på att de bör ha samma längd.

MIDAS-data har data för flera tidsperioder, och enda tillägget är att man då använder sig av `dims`, t.ex. för att läsa in `PGI` för december 2012:

```{r, eval=F}
a <- cdb("Q:/MIDAS", na = 0)
pgi <- a["PGI", c(2012, 12)]
```

Som ni ser så kan man även ange `na = 0` för att ersätta `NA`-värden med `0`.

---

## Best practices för programdesign

---

## Att lära sig mer om R

- R:s community
- Stack Overflow
- GitHub

---

## Avslutning och utblick

---

## Kurslitteratur

```{r,results="hide"}

```
